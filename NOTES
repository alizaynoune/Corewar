#Pseudo-Assembly:

	+ Instructions:

			  PARAM1		PARAM2			PARAM3

		* ldi <reg|dir|ind> <reg|dir> 		<reg>		: reads 4 bytes from the address PC + (PARAM1 + PARAM2) % IDX_MOD and writes it back to PARAM3(registry)
		* sti <reg>			<reg|dir|ind>	<reg|dir>	: writes the value of the rigister to the address (position + (P2 + P3) % IDX_MOD.

		* fork <dir>			-				-		: copies the actual process to the address PARAM1 % IDX_MOD.

binary file structure:

---> 	MAGIC HEADER: 4 bytes containing a special hexadecimal value indicating the the file is executable (elf for instance in GNU/Linux exec files)

--->	CHAMPION NAME: 128 bytes long compensated with \0 if the champion name is less

--->	NULL: 4 Bytes long, serves as a boundary between components

--->	CHAMP EXEC CODE SIZE: 4 bytes long, contains the champions executable code size in bytes, this info is used by the VM to make sure the champion code
								does not exceed CHAMP_MAX_SIZE

--->	CHAMP COMMENT: 2048 bytes long. analog to the champion name.its length is defined by the constant COMMENT_LENGTH

--->	NULL: again...

--->	CHAMP EXEC CODE: unlike name and comment, it is not padded by null bytes. 


for a given instruction we must set the following dimensions:

	example:

	loop:
			sti r1, %:live, %1
	live:
			live %0
			ld %0, r2
			zjmp %:loop

	+ operation code: (for example sti has a code 0x0b in hex).
	+ argument type code: binary-encoded, each argument type is coded in a pair of bits. the fourth pair is set to 00(binary)
		T_REG (r) ---> 01
		T_DIR (%) ---> 10
		T_IND     ---> 11


#TODO: Write a program that dumps data in binary to a given file
